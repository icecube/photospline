from typing import Any, Sequence
import numpy as np
import numpy.typing as npt

class SplineTable:
    coefficients: npt.NDArray[np.float32]
    extents: tuple[tuple[float, float], ...]
    knots: tuple[npt.NDArray[np.float32], ...]
    ndim: int
    order: tuple[int, ...]

    def __init__(self, path: str): ...
    @classmethod
    def stack(
        cls,
        tables: Sequence[SplineTable],
        coordinates: Sequence[float],
        stackOrder: int = 2,
    ) -> SplineTable:
        """ """
        ...
    def aux_value(self, *args, **kwargs) -> Any: ...
    def convolve(self, *args, **kwargs) -> Any: ...
    def deriv(self, *args, **kwargs) -> Any: ...
    def evaluate(self, *args, **kwargs) -> Any: ...
    def evaluate_gradient(self, *args, **kwargs) -> Any: ...
    def evaluate_simple(self, *args, **kwargs) -> Any: ...
    def grideval(self, *args, **kwargs) -> Any: ...
    def permute_dimensions(self, *args, **kwargs) -> Any: ...
    def search_centers(self, *args, **kwargs) -> Any: ...
    def write(self, *args, **kwargs) -> Any: ...
    def __call__(self, *args, **kwargs) -> Any: ...

class ndsparse:
    def __init__(self, rows: int, ndim: int) -> None: ...
    @classmethod
    def from_data(
        cls, values: npt.ArrayLike, weights: None | npt.ArrayLike = None
    ) -> tuple[ndsparse, ndsparse]: ...
    def insert(self, value: float, indices: Sequence[int]) -> None: ...

def bspline(knots: npt.ArrayLike, x: float, index: int, order: int) -> float: ...
def glam_fit(
    data: ndsparse,
    weights: ndsparse,
    coordinates: Sequence[Sequence[float]],
    knots: Sequence[Sequence[float]],
    order: Sequence[int],
    smoothing: Sequence[float],
    penaltyOrder: Sequence[int],
    monodim: None | int = None,
    verbose: int = 1,
) -> SplineTable: ...
