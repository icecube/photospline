from typing import Sequence
import numpy as np
import numpy.typing as npt

class SplineTable:
    coefficients: npt.NDArray[np.float32]
    extents: tuple[tuple[float, float], ...]
    knots: tuple[npt.NDArray[np.float32], ...]
    ndim: int
    order: tuple[int, ...]
    def aux_value(self, key: str) -> str: ...

    def __init__(self, path: str): ...
    @classmethod
    def stack(
        cls,
        tables: Sequence[SplineTable],
        coordinates: Sequence[float],
        stackOrder: int = 2,
    ) -> SplineTable:
        """ """
        ...
    
    def convolve(self, dim: int, knots: Sequence[float]) -> None: ...
    def permute_dimensions(self, permutation: Sequence[int]) -> None: ...
    def write(self, path: str) -> None: ...

    def search_centers(self, x: Sequence[float]) -> Sequence[int]: ...
    def deriv(self, x: Sequence[float], centers: Sequence[int], derivatives: Sequence[int]) -> float: ...
    def evaluate(self, x: Sequence[float], centers: Sequence[int], derivatives: Sequence[int]) -> float: ...
    def evaluate_gradient(self, x: Sequence[float], centers: Sequence[int]) -> float: ...
    def evaluate_simple(self, x: Sequence[float]) -> float: ...
    def __call__(self, x: Sequence[float]) -> float: ...

    def grideval(self, coords: Sequence[npt.ArrayLike]) -> npt.NDArray[np.float64]: ...

class ndsparse:
    def __init__(self, rows: int, ndim: int) -> None: ...
    @classmethod
    def from_data(
        cls, values: npt.ArrayLike, weights: None | npt.ArrayLike = None
    ) -> tuple[ndsparse, ndsparse]: ...
    def insert(self, value: float, indices: Sequence[int]) -> None: ...

def bspline(knots: npt.ArrayLike, x: float, index: int, order: int) -> float: ...
def glam_fit(
    data: ndsparse,
    weights: ndsparse,
    coordinates: Sequence[Sequence[float]],
    knots: Sequence[Sequence[float]],
    order: Sequence[int],
    smoothing: Sequence[float],
    penaltyOrder: Sequence[int],
    monodim: None | int = None,
    verbose: int = 1,
) -> SplineTable: ...
